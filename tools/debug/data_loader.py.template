#!/usr/bin/env python3
"""
车牌识别项目的调试数据加载器

用于 Polygraphy 调试工具的自定义数据加载器，专门为车牌检测模型提供预处理后的输入数据。

使用方法:
    方法1: 作为数据加载器脚本
    polygraphy run model.onnx --data-loader-script tools/debug/data_loader.py

    方法2: 生成JSON格式的输入数据
    python tools/debug/data_loader.py
    polygraphy run model.onnx --load-inputs debug_inputs.json
"""

import os
import cv2
import numpy as np
from pathlib import Path
from typing import Generator, Dict, Tuple, Optional
from polygraphy.json import save_json

# 项目根目录
PROJECT_ROOT = Path(__file__).parent.parent.parent

# 默认图像路径和模型输入配置
DEFAULT_IMAGE_PATH = PROJECT_ROOT / "data" / "sample.jpg"
INPUT_SHAPE = ({{INPUT_SIZE}}, {{INPUT_SIZE}})  # (height, width)
INPUT_NAME = "images"  # 默认ONNX输入名称，可根据具体模型调整


class VehiclePlateDataLoader:
    """车牌识别模型的数据加载器类"""
    
    def __init__(
        self,
        input_shape: Tuple[int, int] = INPUT_SHAPE,
        input_name: str = INPUT_NAME,
        padding_value: int = 114,
        normalize: bool = True
    ):
        self.input_shape = input_shape
        self.input_name = input_name
        self.padding_value = padding_value
        self.normalize = normalize
        
    def preprocess_image(self, image_path: str) -> Tuple[np.ndarray, Dict]:
        """预处理单张图像 - 直接resize不保持长宽比"""
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"图像文件不存在: {image_path}")
            
        # 读取图像
        image = cv2.imread(image_path)
        if image is None:
            raise ValueError(f"无法读取图像文件: {image_path}")
            
        original_shape = image.shape[:2]  # (height, width)
        
        # 直接resize到目标尺寸，不保持长宽比
        resized_image = cv2.resize(
            image, 
            (self.input_shape[1], self.input_shape[0]),  # (width, height)
            interpolation=cv2.INTER_LINEAR
        )
        
        # 数据类型转换和归一化
        if self.normalize:
            # 转换为float32并归一化到[0,1]
            processed_image = resized_image.astype(np.float32) / 255.0
        else:
            processed_image = resized_image.astype(np.float32)
        
        # 转换通道顺序：HWC -> CHW
        processed_image = np.transpose(processed_image, (2, 0, 1))
        
        # 添加batch维度：CHW -> BCHW
        input_tensor = np.expand_dims(processed_image, axis=0)
        
        # 构建元数据
        metadata = {
            "original_shape": original_shape,
            "target_shape": self.input_shape,
            "resize_method": "direct_resize",
            "image_path": str(image_path)
        }
        
        return input_tensor, metadata
    
    def load_single_image(self, image_path: Optional[str] = None) -> Dict[str, np.ndarray]:
        """加载并预处理单张图像，返回Polygraphy兼容的字典格式"""
        if image_path is None:
            image_path = str(DEFAULT_IMAGE_PATH)
            
        input_tensor, metadata = self.preprocess_image(image_path)
        
        return {self.input_name: input_tensor}
    
    def generate_data(
        self, 
        image_paths: Optional[list] = None,
        num_iterations: int = 1
    ) -> Generator[Dict[str, np.ndarray], None, None]:
        """生成多个批次的输入数据"""
        if image_paths is None:
            image_paths = [str(DEFAULT_IMAGE_PATH)]
            
        # 循环生成指定数量的批次
        for i in range(num_iterations):
            # 循环使用图像列表
            image_path = image_paths[i % len(image_paths)]
            yield self.load_single_image(image_path)


def load_data() -> Generator[Dict[str, np.ndarray], None, None]:
    """Polygraphy 数据加载器入口函数"""
    # 创建数据加载器实例
    data_loader = VehiclePlateDataLoader()
    
    # 检查默认图像是否存在
    if not DEFAULT_IMAGE_PATH.exists():
        print(f"警告: 默认图像文件不存在: {DEFAULT_IMAGE_PATH}")
        print("请确保 data/sample.jpg 文件存在")
        # 生成随机数据作为回退
        random_data = np.random.rand(1, 3, *INPUT_SHAPE).astype(np.float32)
        yield {INPUT_NAME: random_data}
        return
    
    # 生成多个批次的数据用于测试
    yield from data_loader.generate_data(num_iterations=1)


def create_debug_inputs_json(output_path: str = "debug_inputs.json"):
    """创建用于调试的JSON格式输入数据文件"""
    print("正在生成调试输入数据...")
    
    # 收集所有可用的测试图像
    data_dir = PROJECT_ROOT / "data"
    available_images = []
    
    # 查找jpg和png图像文件
    for ext in ["*.jpg", "*.jpeg", "*.png", "*.bmp"]:
        available_images.extend(data_dir.glob(ext))
    
    if not available_images:
        print("警告: data目录中没有找到图像文件，使用随机数据")
        # 生成随机输入数据
        input_data = []
        for i in range(3):
            random_tensor = np.random.rand(1, 3, *INPUT_SHAPE).astype(np.float32)
            input_data.append({INPUT_NAME: random_tensor})
    else:
        print(f"发现 {len(available_images)} 个图像文件:")
        for img_path in available_images:
            print(f"  - {img_path.name}")
        
        # 使用真实图像创建输入数据
        data_loader = VehiclePlateDataLoader()
        input_data = []
        
        # 选择前3个图像（或循环使用如果图像少于3个）
        selected_images = available_images[:3] if len(available_images) >= 3 else available_images
        
        for img_path in selected_images:
            try:
                feed_dict = data_loader.load_single_image(str(img_path))
                input_data.append(feed_dict)
                print(f"✓ 成功预处理图像: {img_path.name}")
            except Exception as e:
                print(f"✗ 预处理图像失败 {img_path.name}: {e}")
                # 添加随机数据作为备选
                random_tensor = np.random.rand(1, 3, *INPUT_SHAPE).astype(np.float32)
                input_data.append({INPUT_NAME: random_tensor})
    
    # 保存到JSON文件
    save_json(
        input_data, 
        output_path, 
        description="车牌识别模型的调试输入数据"
    )
    
    print(f"✓ 调试输入数据已保存到: {output_path}")
    print(f"  - 包含 {len(input_data)} 个输入样本")
    print(f"  - 输入形状: {input_data[0][INPUT_NAME].shape}")
    print(f"  - 输入名称: {INPUT_NAME}")
    print("\n使用方法:")
    print(f"  polygraphy run model.onnx --load-inputs {output_path}")


def print_data_info():
    """打印数据加载器信息和使用说明"""
    print("=" * 60)
    print("车牌识别项目 - Polygraphy 调试数据加载器")
    print("=" * 60)
    print(f"项目根目录: {PROJECT_ROOT}")
    print(f"默认图像路径: {DEFAULT_IMAGE_PATH}")
    print(f"模型输入尺寸: {INPUT_SHAPE}")
    print(f"输入节点名称: {INPUT_NAME}")
    print()
    
    print("支持的使用方式:")
    print("1. 作为数据加载器脚本:")
    print("   polygraphy run model.onnx --data-loader-script tools/debug/data_loader.py")
    print()
    print("2. 生成JSON输入文件:")
    print("   python tools/debug/data_loader.py")
    print("   polygraphy run model.onnx --load-inputs debug_inputs.json")
    print()
    print("3. Python API调用:")
    print("   from tools.debug.data_loader import VehiclePlateDataLoader")
    print("   loader = VehiclePlateDataLoader()")
    print("   data = loader.load_single_image('path/to/image.jpg')")
    print("=" * 60)


if __name__ == "__main__":
    # 打印信息
    print_data_info()
    
    # 检查默认图像是否存在
    if DEFAULT_IMAGE_PATH.exists():
        print(f"✓ 发现默认图像: {DEFAULT_IMAGE_PATH}")
        
        # 测试预处理功能
        try:
            data_loader = VehiclePlateDataLoader()
            input_tensor, metadata = data_loader.preprocess_image(str(DEFAULT_IMAGE_PATH))
            
            print(f"✓ 图像预处理成功:")
            print(f"  - 原始尺寸: {metadata['original_shape']}")
            print(f"  - 目标尺寸: {metadata['target_shape']}")
            print(f"  - 调整方法: {metadata['resize_method']}")
            print(f"  - 输出形状: {input_tensor.shape}")
            print(f"  - 数据范围: [{input_tensor.min():.3f}, {input_tensor.max():.3f}]")
            
        except Exception as e:
            print(f"✗ 图像预处理失败: {e}")
    else:
        print(f"✗ 默认图像不存在: {DEFAULT_IMAGE_PATH}")
    
    # 生成JSON输入数据文件
    create_debug_inputs_json()